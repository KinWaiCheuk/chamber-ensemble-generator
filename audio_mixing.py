"""Automatic audio loudness normalization and mixing procedure, adapted from SLAKH dataset."""

import numpy as np
import os
import glob
import pyloudnorm as pyln
import librosa
from tqdm import tqdm
import argparse

from utils.file_utils import pickle_load, pickle_dump
from midi_ddsp.utils.audio_io import save_wav
from utils.file_utils import get_config


def audio_normalization(data_dir, output_dir, normalization_factor, target_peak, sample_rate):
    # https://github.com/ethman/slakh-generation/blob/e6454eb57a3683b99cdd16695fe652f83b75bb14/render_by_instrument.py#L439

    # if output_dir is provided, then save to the output_dir.
    if output_dir:
        output_dir = os.path.join(output_dir, os.path.basename(data_dir))
        os.makedirs(output_dir, exist_ok=True)
    else:  # else, change in place
        output_dir = data_dir

    # load metadata
    pickle_path = os.path.join(data_dir, 'metadata.pickle')
    metadata = pickle_load(pickle_path)

    wav_files = glob.glob(f'{data_dir}/*.wav')
    stem_wav_files = [f for f in wav_files if 'mix.wav' not in f]  # exclude mix wav
    all_audio = []
    for wav_file in stem_wav_files:
        wav, _ = librosa.load(wav_file, sr=sample_rate, mono=True)
        all_audio.append(wav)

    meter = pyln.Meter(sample_rate)
    target_gain = np.power(10.0, target_peak / 20.0)
    loudnesses = [meter.integrated_loudness(a) for a in all_audio]
    metadata['stem_integrated_loudness'] = {j: float(loudnesses[j]) for j in range(len(loudnesses))}
    if np.any(np.isinf(loudnesses)):
        raise RuntimeError('One or more sources have -inf loudness!')

    normalized_audio = [pyln.normalize.loudness(a, loudnesses[j], normalization_factor)
                        for j, a in enumerate(all_audio)]
    mixture = np.sum(normalized_audio, axis=0)

    peak = np.max(np.abs(mixture))
    if peak >= target_gain:
        gain = target_gain / peak
        mixture *= gain

        if np.any(np.isnan(mixture)):
            raise RuntimeError('This mixture contains NaNs!!!')

        normalized_audio = [a * gain for a in normalized_audio]

        metadata['overall_gain'] = float(gain)

    else:
        metadata['overall_gain'] = 1.0

    metadata['normalization_factor'] = normalization_factor
    metadata['target_peak'] = target_peak
    metadata['normalized'] = True

    # save metadata
    pickle_dump(metadata, os.path.join(output_dir, 'metadata.pickle'))

    # save stem
    for i, wav_file in enumerate(stem_wav_files):
        save_wav(normalized_audio[i], os.path.join(output_dir, os.path.basename(wav_file)), sample_rate=sample_rate)

    # save mix
    save_wav(mixture, os.path.join(output_dir, 'mix.wav'), sample_rate=sample_rate)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Audio Normalization')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--synthesis_dir', type=str, default=None, metavar='N',
                       help='the directory generated by MIDI-DDSP synthesis.')
    group.add_argument('--multi_synthesis_dir', type=str, default=None, metavar='N',
                       help='the directory containing multiple folders generated by MIDI-DDSP synthesis.')
    parser.add_argument('--output_dir', type=str, default=None, metavar='N',
                        help='the directory for output.')
    args = parser.parse_args()

    config = get_config()

    if args.synthesis_dir:
        synth_dir_list = [args.synthesis_dir]
    elif args.multi_synthesis_dir:
        synth_dir_list = glob.glob(f'{args.multi_synthesis_dir}/*/')

    for synth_dir in tqdm(synth_dir_list):
        audio_normalization(synth_dir,
                            args.output_dir,
                            normalization_factor=config['mix_normalization_factor'],
                            target_peak=config['mix_target_peak'],
                            sample_rate=config['sample_rate'])
